<!DOCTYPE html>
<html>
	<head>
		<link type="text/css" rel="stylesheet" href="stylesheet.css"/>
		<title>Karen Shay West's Home Page</title>
	</head>
	<body>
		<div id="header">
           <!-- <img id="pic"
           src="https://github.com/KarenWest/myPhotosAndVideosForWebSite/KarenShayWestAge50Dec2015_crop.jpeg"/>-->
	          <div id="photo"> <a href="KarenShayWestAgeAlmost50Dec2016.jpg"><img alt=""
            src="KarenShayWestAgeAlmost52Dec2016.jpg" style="border: 0px solid; width: 85px;
            height: 85px;"></a> </div>

            <ul></ul>
			<p id="name">Karen Shay West: Tel: (508) 844-9776</p>
			<a href="mailto:KarenWest15@gmail.com"><p id="email">KarenWest15@gmail.com</p></a>
			<p id="notice"><strong><br>UNDER CONSTRUCTION WEB SITE</strong>,
			  All links now work.  However, the web site is still
			  under construction, since while building it, I
			  learned how better to design it going forward.
			  Future Plans are to shorten web pages if they are 
			  long in description by creating links to other
			  short length web pages within them.  I will add to
			  it over time as well, and I am still learning more
			  about the web languages, so I may tweak it as I do
			  that too. <br><strong>NOTE: LEFT HAND COLUMN
			  LINKS:</strong> Recent and on going online projects
			  and learning in both technical areas and business 
			  humanities.<br><strong>NOTE: MAIN PAGE:</strong> Details 
			  Professional Work Experience, Formal Education (BS
			  and MS) along with recent online learning summaries</p>
	        
	        <ul></ul>

	    <a href="https://drive.google.com/open?id=0B0ao1LZvdelIcWtzam0tX0gwTjQ"><p id="toprightresume">Link
	    to my resume (CV)!</p></a>
            <ul></ul>
            <a href="http://www.linkedin.com/in/karenshaywest"><p id="toprightlinkedin">Click to go to
            my Linked In site!</p></a>
            <ul></ul>
            <a href="https://github.com/KarenWest"><p id="toprightgithub">Click to go to my Git Hub site!</p></a>
	    <a href='http://www.counter12.com'><p id="centertopcounter">Number
	    of web site visitors since May 26th, 2017!</p></a>
	    <div id="sitevisitorcounter"><img src='http://www.counter12.com/img-yBdW1Cdc49425Zb1-17.gif'
				 border='0'
				 alt='counter'><script type='text/javascript'
							   src='http://www.counter12.com/ad.js?id=yBdW1Cdc49425Zb1'></script></div>

		</div>
		<div class="cshellleft">
		  <ul>
		    <li id="left-01"><a href="index.html">BELOW: List of Recent
		    Learning - CLICK HERE to Go To My Home Page Resume</a></li>
		    <li id="left-02"><a href="currentLearningInProgress.html">Currently
		    focusing on web and app development while job searching,
		    since previously expertise was embedded systems, C
		    programming, with Electrical Engineering background</a></li>
</a></li>
		    <li id="left-03"><a href="androidappsjavaxml.html">Android Apps Java XML</a></li>
		    <li id="left-04"><a href="randdataanalysis.html">R and Data Analysis</a></li>
		    <li id="left-05"><a href="softwareandhardwaresecurity.html">Software
		  And Hardware Security</a></li>
		    <li id="left-06"><a href="appliedpythonexamples.html">Applied Python Examples</a></li>
		    <li id="left-07"><a href="pythonusedforartificialintelligenceonpacman.html">Python Used For Artificial Intelligence On Pacman</a></li>
		    <li id="left-08"><a href="makinganddeployingawebsite.html">Making
	    And Deploying A Website</a></li>
		    <li id="left-09"><a href="matlabandwiresharkandwirelesscommunicationsystems.html">MATLAB
		  and WireShark And Wireless Communication Systems</a></li>
		    <li id="left-10"><a href="gitandgithubandrubyonrailsappsintro.html">Git
	    And Git Hub And Ruby On Rails Apps Intro</a></li>
		    <li id="left-11"><a href="computetechnologyforsmartphone.html">Compute
	    Technology For Smart Phone</a></li>
	            <li id="left-12"><a href="embeddedsystemslabs.html">Embedded Systems Projects</a></li>
		    <li id="left-13"><a href="cshell.html">C Shell Linux
	            Command Interpreter</a></li>
		    <li id="left-14"><a href="cwebserver.html">C Web Server To Physical Computing</a></li>
		    <li id="left-15"><a href="networkprotocols.html">Network Protocols</a></li>
		    <li id="left-16"><a href="databasespatialcomputingsqlmapsandgps.html">Database
	    Spatial Computing SQL maps And GPS</a></li>
		    <li id="left-17"><a href="agilentkeysighttektronixworkshops.html">Agilent
	    Keysight Tektronix Workshops on Their Equipment and Radio Frequencies</a></li>
		    <li id="left-18"><a href="economicsbusinessentrepreneurhumanrightslaws.html">Economics,
		    Business, Entrepreneur, Laws, and Human Rights</a></li>

		  </ul>
		</div>

		<div class="cshellright">
		  <h4>Very Basic C Shell Linux Command Line Interpreter</h4>
		  <ul>
		    <li>a basic multi-process C shell Linux command interpreter</li>
		    <li>in the future, it may be expanded to take a traveling
		    salesman threads, with a sorter of their paths</li>

		    <li>goals of implementation were to become more familiar with the primitives used in process control and inter-process communication</li>

		    <li>future goals may be to simulate a multi-threaded
		    environment that implements inter-process communication,
		    signal handling, and a stronger understanding of flow
		    control</li>
		    </ul>
		    <h4>Two primary aspects of this project:</h4>
		    <ul>
		      <li>implementing a shell environment to process command
			line input specification and execution of a parallel 
			program that is either comprised of multiple processes 
			or threads</li>

		      <li>Concepts Used to complete this project included: 
			inter-process communication, (including pipes, signals
			, shared memory), process creation and execution.</li>
			
		      <li>Relevant functions include: 
			getcontext, makecontext, setcontext, swapcontext, 
			sigsetjump, siglongjump, kill, pipe, popen, shmget, 
			shmctl, shmat, fork, execve, execvp, etc.</li>
		    </ul>
		    <h4>Four Programs Involved</h4>
		      <p>Only the first very basic version of the shell is done and the rest are future work:</p> 
		      <ul>
			<li>Basic shell (done in C) for specifying and
			executing programs, called "myshell" .</li>

			<li>Goal: to implement a basic shell called "myshell", 
			  to learn how a command interpreter works. It's a 
			  simple parser to interpret commands,  that uses 
			  fork/exec functions to create and execute these 
			  commands. I/O redirection and the use of pipes was 
			  required.</li>

			<li>"Myshell" specification: similar to the "bash" 
			  shell, with the following requirements:</li>
			<ol>

			  <li>Execution file: the execution file called
			  "myshell".</li>

			  <li>Shell prompt: If the input to the "myshell" 
			    program is from a terminal, you should print 
			    "myshell>" as the prompt for the user to type in 
			    the shell command. If the input is from a file, 
			    you should not print any prompt, as this will help 
			    when it comes to testing your projects. NOTE: You 
			    can use the "isatty" function to determine whether 
			    the input (via a specific file descriptor) is from 
			    a terminal or not.</li>

			  <li>Command execution and shell termination:
			    "myshell" reads its input from stdin, parsing the 
			    command line to determine how to execute the shell 
			    request. Termination of "myshell" occurs either 
			    when a user types <em>ctrl-d</em>, or when the
			    program issues an "exit()" call due to some 
			    error/termination condition. </li>
			  </ol>
		      </ul>
		      <h4>Description of the valid command lineformats.</h4>
		      <ul>
			<li>"Cmd"--A single command that identifies the 
			  name of a program file.</li>

			<li>"cmd; cmd"--A sequence of commands: "myshell" 
			  should execute them one after another.</li>

			<li>"cmd \> output_file"--Redirect stdout of the cmd 
			  to the file with the name "output_file".</li>

			<li>"cmd \< input_file"--Redirect stdin of the cmd 
			to the file with the name "input_file".</li>

			<li>"cmd 1> output_fil"e--Redirect stdout of the cmd 
				to the file with the name "output_file".</li>

			<li>"cmd 2> output_file" - Redirect stderr of the 
			      cmd to the file with the name "output_file".</li>

			<li>"cmd &> output_file" - Redirect both stdout and 
			      stderr of the cmd to the file with the name 
			      "output_file".</li>

			<li>"cmd1 | cmd2 | cmd3" - Pipeline the output of 
			      the command before each "|" symbol to the input
			      of the command after the same "|" symbol.</li>

			<li>"cmd &" - "myshell" should let cmd execute in 
			      the background, so that the shell can interpret 
			      further input commands.</li>
			</ul>
			<h4>Testing It:</h4>
			<p>At Linux prompt, type <em>gdb myshell</em> , which starts
			  the gdb debugger. It works for some but not all of
			  the specified cases.</p>
			<h4>Test cases that I tried before setting project
			aside for now:</h4>

			<ul>
			  <li>Test: Shell will list all files in directory.</li>

			  <li>Command: ls</li>

			  <li>Test: Shell will first list all files in
			    directory.  Then it will list information
			    about the active processes running.</li>

			  <li>Command: ls;ps</li>

			  <li>Test: Shell will do a directory listing
			    and send it to the output file "lsOutputFile".</li>

			  <li>Command: ls > lsOutputFile</li>

			  <li>Test: Shell will do a directory listing
			    and pipe this output list of directory files 
			    to be the input to the second command
			    running as a process in the shell, grep, 
			    which will then output only the files that 
			    match the string passed as input to grep's 
			    command, "lsOut", and send this list of
			    files to the standard out console output.</li>
			  
			  <li>Command: ls | grep lsOut</li>

			  <li>How I Run and Test it: run gdb with the 
			    myshell binary, and after running it, type 
			    the test cases in the test case file at the
			    shell prompt and then view the output.  In
			    the case you send the output to an output
			    file, after the command is done, you must do
			    the command "more outputFileName.txt" to
			    view the output from the previous command
			    you ran.</li>
			</ul>
			<h4>Special Input:</h4>
			<ul>
			  <li><em>ctrl-c</em> is the default key sequence to send a 
			    "SIGINT" signal to a process. </li>
			  <li>In "myshell", you should intercept this signal, 
			    and send it to all "foreground" processes to stop 
			    them instead of stopping "myshell".</li>
			</ul>
			<h4>Prevent "zombie" children:</h4>
			<ul>
			  <li>when a command running in the background 
			    finishes, it must inform the "myshell" (parent) 
			    process via a "SIGCHLD" signal. </li>
			  <li>"myshell" can then keep track of which child 
			    processes are still active.</li>
			</ul>

			<h4>Basic Shell operation:</h4>
			<ul>
			  <li>You should use the "fork" syscall to create each 
			    child of "myshell" and then one of the "exec*" 
			    functions to execute the command in the 
			    corresponding child's address space. </li>
			  <li>You should also use either the "wait" or 
			    "waitpid" function to determine the exit status of 
			    a terminating child.</li>
			  <li>For output redirection and piping between 
			    processes: to redirect a file descriptor to stdin, 
			    stdout, or stderr you can use the "dup2"
			    function.</li>
			</ul>

			<h4>Code developed in a series of stages:</h4>
			<ol>
			  <li>write and test a parser to read the command
			    lines--this works</li>
			  <li>get the simple commands to work--this works</li>
			  <li>get I/O redirection to work--this works</li>
			  <li>get pipes to work--this works for some cases but
			    not with 2nd command sent to an output file
			    instead of stdout</li>
			  <li>get "&" to work--not implemented yet</li>
			  <li>Parsing shell strings: in this project, you only 
			    need to implement a simple command line parser, in 
			    which we use "space" as the delimiter between 
			    command "tokens".--this works</li>
			  <li>You can use support libraries such as the Gnu 
			    readline library for command line parsing.</li>
			  <li>A multi-process version of the traveling salesman 
			    problem, called <em>tsp_p</em>--future work.</li>
			  <li>A multi-threaded version of the traveling
			    problem, called <em>tsp_t</em>, with an added
			    bonus of implementing it without the SYSV context 
			    functions.  Solutions that bind user level threads 
			    with kernel threads are also a bonus, and using 
			    pthreads or any other threads library is not the 
			    approach to take, and instead, you create your own 
			    threads.  It was also recommended NOT to rely on 
			    the Linux clone() call in the thread creation 
			    solution, if at all.  The solution can bind user 
			    level threads onto user level threads, but you 
			    still need to use a different approach for making 
			    the portable user--level threads--future work.</li>
			  <li>A sorter program, called <em>tspsort</em>, that
			  sorts the paths found in the traveling salesman
			  problem, from shortest path to longest path
			  distance--future--work.</li>
			</ol>
			<h4>Testing Involved In Future Work:</h4>
			<p>In <em>myshell</em>, run <em>tsp_p < input_graph | tspsort >
			tsp_p.out”</em>

			<p><em>tsp_p</em> computes all possible paths through a graph 
			  (G) of vertices (V) and edges (E).</p>
			<ul>
			  <li>A path is defined as an ordered list of nodes 
			    from a starting point, S, visiting all other 
			    nodes in V exactly once, and then returning back 
			    to S.</li>

			  <li>a path distance is defined as the sum of all 
			    edge weights between pairs of nodes in G visited 
			    along a specific path each path along the route 
			    with its overall distance will be the output to 
			    stdout by <em>tsp_p</em> as it is discovered the
			    result is <em>piped</em> by “myshell” to stdin of
			    <em>tspsort</em>, which collects all paths and
			    orders them from shortest to longest distance</li>

			  <li>In <em>myshell</em>, run <em>tsp_t < input_graph | tspsort 
							 > tsp_t.out</em>, with the same goals with the thread version as above with the process version</li>
			  </ul>

			<h4>Traveling Salesman Multi-Process Version--Future Work:</h4>
			<ul>
			  <li>Problem: The problem to be addressed is a
			    parallel implementation of the Travelling Salesman 
			    Problem (TSP) on an input graph, G={V,E},
			    comprising a set of nodes or vertices, V, and a
			    set of edges, E. Your main program (called
			    <em>tsp_p</em>) is to be invoked as follows: 
			    <em>$ tsp_p</em></li>
			  <li>It then reads an input graph from stdin. You can 
			    assume the input graph, G has |V|=n vertices 
			    representing different cities. </li>
			  <li>The graph itself can be represented as an n*n 
			    distance matrix, D,such that D[i,j] is the
			    distance between city i and city j. </li>
			  <li>The diagonal of the matrix has distance 0 for 
			    each D[i,i] . You can assume all distances are in 
			    integers over some predefined range 
			    [0..MAX_DISTANCE] and the number of cities, n, is 
			    limited to a maximum value MAX_NODES.</li>
			  <li>Code in future work will be tested on values of 
			    n not much above single digits but code will be
			    designed to be as efficient as possible, so that
			    it can scale to large input graphs.</li>
			  <li>Not all cities need to have a direct path
			    between them. In this case you can assume there is 
			    no edge connecting them. In the input graph you
			    can assume a value for D[i,j] = <em>­1</em> if
			    there is no edge directly connecting cities/nodes 
			    i and j.</li>
			  <li>For all pairs of cities with direct paths, or 
			    edges between them, then your distance matrix must 
			    contain a valid value. You can assume MAX_DISTANCE 
			    is set to 255.</li>
			  <li>For each node in G, you should consider it the 
			    starting point of all possible paths to all other 
			    nodes. You should create a separate process (n in 
			    total) for each starting node and compute all
			    paths from that starting point to all other nodes 
			    and back again to the starting point.</li>
			  <li>The output of <em>tsp_p</em> is a list of paths
			  along with overall distance </li>
			  <li>A path is defined as an ordered sequence of
			    nodes, from a starting point S visiting all other 
			    nodes exactly once and then returning back to
			    S.</li>
			  <li>The paths should be output along with their 
			    distances to stdout.</li>
			  </ul>
			<h4>The Big Picture of the Multi-process, Traveling
			Salesman Problem:</h4>
			<ol>
			  <li>The first step is for the parent process to the 
			    input graph from stdin, and perform appropriate 
			    error checks, to verify its correctness.</li>
			  <li>The parent process then creates a shared memory 
			    segment which is big enough for communications 
			    between parent and child processes. Using the 
			    "fork" syscall, the parent creates n child 
			    processes.</li>
			  <li>A child process uses one of the exec functions
			    to map a program file called "find_paths" into its 
			    address space.</li>
			  <li>The "find_paths" program will take a starting 
			    node, S, in the input graph and calculate the 
			    distances of all possible paths from that node to 
			    all other nodes and back again to S. Aside from S, 
			    all other nodes along a valid path should only be 
			    visited once. </li>
			  <li>The parent process waits until all of the child 
			    processes have finished, and then outputs the 
			    resultant set of paths and their distances
			    stdout.</li>
			  <li>Each child will send back its paths to the
			    parent via shared memory. You need to establish 
			    sufficiently large shared memory between each
			    child and the parent. This memory region does not 
			    need to be big enough to store all paths but could 
			    instead form a communication channel to exchange 
			    paths as they are produced.</li>
			  <li>Note that each process has a unique starting 
			    point. Since there are n possible nodes (or cities 
			    in the input graph) then each of the n child 
			    processes has a different one of these nodes as
			    its starting point.</li>
			  </ol>

			<h4>Traveling Salesman, Multi-threaded Version:</h4>
			<p>Problem: The problem to be addressed is the same 
			  as in "tsp_p", except you will use multiple
			  threads to calculate paths through a graph instead 
			  of separate child processes. Your multithreaded 
			  program should be called "tsp_t".</p>

			<h4>The Big Picture of the Multi-threaded traveling
			salesman version:</h4>
			<ol>
			  <li>The first step is for "tsp_t" to read an input 
			    graph as before, from stdin, and perform 
			    appropriate error checks, to verify its
			    correctness.</li>
			  <li>Once the "tsp_t" program has read the input 
			    graph, it will create a series of threads to help 
			    solve the Travelling Salesman Problem.</li> 
			  <li>To create threads, you cannot use any supporting 
			    libraries for thread creation. Instead, you must 
			    write a function called my_thr_create(), as 
			    follows: <em>void my_thr_create(void (*func) (int),
			    int thr_id);</em></li>

			  <li>The first argument is a pointer to a function for 
			    the thread to execute, while the second argument 
			    is a unique integer thread ID that you create for 
			    each new thread. NOTE: To establish the concept of 
			    a thread, you will either need to establish a 
			    "ucontext_t" for each thread having a given ID, so 
			    that you can use setcontext/swapcontext to 
			    save/restore each thread's state, or you can use 
			    (sig)setjmp/(sig)longjmp/sigaltstack to implement
			    the functionality of the context handling 
			    functions.</li>
			  <li>A solution that avoids the use of 
			    set/swapcontext/etc functions is considered a
			    better solution.</li>

			  <li>Since the main thread and all subthreads share 
			    the process memory space, there is no need to use 
			    separate shared memory to store all discovered 
			    paths. </li>
			  <li>When all sub­threads have finished their 
			    "find_paths" operations, the main thread will then 
			    output the resultant set of paths to stdout.</li>
			  <li>Hints For Future Work: To create your threads
			    you will need to understand how context control 
			    works. This is documented in the GNU document on 
			    System V contexts.</li>
			  <li>A more portable approach to implementing
			  threads, that requires only setjmp/longjmp, 
			    sigaltstack and signal handling is considered a
			  better solution.</li>
			</ol>
			
		</div>
	</body>
</html>
