<!DOCTYPE html>
<html>
	<head>
		<link type="text/css" rel="stylesheet" href="stylesheet.css"/>
		<title>Karen Shay West's Home Page</title>
	</head>
	<body>
		<div id="header">
           <!-- <img id="pic"
           src="https://github.com/KarenWest/myPhotosAndVideosForWebSite/KarenShayWestAge50Dec2015_crop.jpeg"/>-->
	          <div id="photo"> <a href="KarenShayWestAgeAlmost52Dec2016.jpg"><img alt=""
            src="KarenShayWestAgeAlmost52Dec2016.jpg" style="border: 0px solid; width: 85px;
            height: 85px;"></a> </div>

            <ul></ul>
			<p id="name">Karen Shay West: Tel: (508) 844-9776</p>
			<a href="mailto:KarenWest15@gmail.com"><p id="email">KarenWest15@gmail.com</p></a>
			<p id="name">UNDER CONSTRUCTION WEB SITE,
			  All links now work.  However, the web site is still
			  under construction, since while building it, I
			  learned how better to design it going forward.
			  Future Plans are to shorten web pages if they are 
			  long in description by creating links to other
			  short length web pages within them.  I will add to
			  it over time as well, and I am still learning more
			  about the web languages, so I may tweak it as I do
			  that too.</p>
	        
	        <ul></ul>
            <!--<a href="https://github.com/KarenWest/myFilesForWebSite/KarenShayWest_4pageResumeCV_June2016.pdf">Link
            to my resume (CV)!</a>-->
	    <a href="https://drive.google.com/open?id=0B0ao1LZvdelIcWtzam0tX0gwTjQ"><p id="email">Link
	    to my resume (CV)!</p></a>
            <ul></ul>
            <a href="http://www.linkedin.com/in/karenshaywest"><p id="email">Click to go to
            my Linked In site!</p></a>
            <ul></ul>
            <a href="https://github.com/KarenWest"><p id="email">Click to go to my Git Hub site!</p></a>

		</div>
		<div class="embeddedleft">
		  <ul>
		    <li id="left-01"><a href="index.html">BELOW: List of Recent
		    Learning - CLICK HERE to Go To My Home Page Resume</a></li>
		    <li id="left-02"><a href="currentLearningInProgress.html">
		    Currently focus: web and app development (while job
		    searching), since prior expertise and strengths were in 
		    embedded C programming, with a strong Electrical
		    Engineering educational background, and business
		    humanities.
		    </a></li>
		    <li id="left-03"><a href="androidappsjavaxml.html">Android Apps Java XML</a></li>
		    <li id="left-04"><a href="randdataanalysis.html">R and Data Analysis</a></li>
		    <li id="left-05"><a href="softwareandhardwaresecurity.html">Software
		  And Hardware Security</a></li>
		    <li id="left-06"><a href="appliedpythonexamples.html">Applied Python Examples</a></li>
		    <li id="left-07"><a href="pythonusedforartificialintelligenceonpacman.html">Python Used For Artificial Intelligence On Pacman</a></li>
		    <li id="left-08"><a href="makinganddeployingawebsite.html">Making
	    And Deploying A Website</a></li>
		    <li id="left-09"><a href="matlabandwiresharkandwirelesscommunicationsystems.html">MATLAB
		  and WireShark And Wireless Communication Systems</a></li>
		    <li id="left-10"><a href="gitandgithubandrubyonrailsappsintro.html">Git
	    And Git Hub And Ruby On Rails Apps Intro</a></li>
		    <li id="left-11"><a href="computetechnologyforsmartphone.html">Compute
	    Technology For Smart Phone</a></li>
	            <li id="left-12"><a href="embeddedsystemslabs.html">Embedded Systems Projects</a></li>
		    <li id="left-13"><a href="cshell.html">C Shell Linux
	            Command Interpreter</a></li>
		    <li id="left-14"><a href="cwebserver.html">C Web Server To Physical Computing</a></li>
		    <li id="left-15"><a href="networkprotocols.html">Network Protocols</a></li>
		    <li id="left-16"><a href="databasespatialcomputingsqlmapsandgps.html">Database
	    Spatial Computing SQL maps And GPS</a></li>
		    <li id="left-17"><a href="agilentkeysighttektronixworkshops.html">Agilent
	    Keysight Tektronix Workshops on Their Equipment and Radio Frequencies</a></li>
		    <li id="left-18"><a href="economicsbusinessentrepreneurhumanrightslaws.html">Economics,
		    Business, Entrepreneur, Laws, and Human Rights</a></li>

		  </ul>
		</div>

		<div class="embeddedright">
		  <h4>C Web Server (part from me, rest given in an online EdX
		  CS50 class from Harvard) and the plans to expand it to
		  interface to the physical computing world:</h4>
		  <a href="https://github.com/KarenWest/webServerInCtoLearnBeforeDoingNewLanguageWebServer">Link
		to the web server in C project class files</a><br>
		<ul></ul>

		<ul>
		  <li>I implemented parts of a basic web server in C, taken
		    from an online class's description.</li><br>
		  <li>I also have plans to learn other ways of doing web
		    servers, in the newer languages for that purpose that
		    people use, as listed in my "current learning"
		    page.</li><br>
		  <li>The parts I wrote for this web server project I used to 
		    get started were in the file listed in the next section 
		    called "server.c":
		    <ul>
		      <li><strong>lookup</strong>, to return the type of web 
			page requested from the client browers, such as html, 
			css, gif, ico, jpg, js (javascript), php, and
			png</li><br>
		      <li><strong>parse</strong>, to extract the absolute 
			path and query from the client web browser's web page 
			request line, and return standard web error messages 
			if the request had an error</li><br>
		      <li><strong>load</strong> to read all bytes from a web 
			page if html, dynamically allocate memory on the heap, 
			and save a pointer to the web page content and length, 
			or if a php web page request, invoke the php 
			interpreter to run the requested php script, and 
			return in content what the php script returned and 
			it's length</li><br>
		      <li><strong>indexes</strong>, which returns  a
			"path/to/a/directory" with either the html or php file 
			extension on the end of it, if it actually
			exists.</li><br>
		      <li><strong>This project helped me learn</strong> 
			to implement a web
			server in a language I know very well, C, before
			learning to do that in the more common way of
			programming web servers these days in languages I do
			not know as well.</li><br>
		      <li><strong>Future plans</strong> may be to expand it to work on a board
			for the physical computing interface environment,
			where the board responds to requests from the client
			web browser requests.</li><br>
		      <li><strong>The socket communications</strong> between this server and
			the client browser were done by the online course
			people.</li><br>
		      <li><strong>The directory structure</strong> for this basic web server in
			C was as follows, and I simply filled in the above
			functions described in the file called
			server.c.</li><br>
		      <li><strong>The directory contained these files for
		      getting started below.</strong><br>
			<ul></ul><br>
			<p>Makefile</p>
			<p>public directory</p>
			<p>cat.html (which has an IMG tag whose src attribute
			is cat.jpg, provided by class project, and we love
			all friendly type animals!!</p>
			<p>cat.jpg</p>
			<p>favicon.ico</p>
			<p>hello.html (has a form thats configured to submit via GET a text field called name to "hello.php"</p>
			<p>hello.php (mostly HTML but inside its body is a bit
			of PHP code to deal with html special characters</p>
			<p>test</p>
			<p>index.html</p>
			<p>index.php</p>
			<p>server.c (implements web server that knows how to serve static content (i.e., files ending in
			  .html , .jpg , et al.) and dynamic content (i.e., files ending in .php ).</p>
		      </li><br>
		      <li><strong>"Usage: server (port number) (path to root)"</strong>
			<ul></ul><br>
			<p>To specify a (TCP) port number on which server
			  should listen for HTTP requests, include (port number) as a 
			  command line argument.</p>
			<p>If you do not specify a port number, the program will 
			  default to port 8080.</p>
			<p>The last command line argument to server should be
			  the PATH to your servers "root" (the directory from
			  which files will be served).</p>
			<p><strong>To Test:</strong></p>
			<p>Server is started with: "./server public"</p>
			<p>Listening on port 8080 (should be output)</p>
			<p>Using the public directory as servers root, the directory from
			which files will be served.</p>
			<p>Under the public dir is the "test/index.html" file.
			  You only specify directories or files underneath
			  the public directory after the localhost:8080 to
			  request web pages.</p>
		      </li><br>

		      <li><strong>Tests:</strong> in client browser while
			  this server is running on same machine:
			<ul>
			  <li>"http://localhost:8080/test/index.html" (starts a
			  video of singer)</li><br>
			  <li>"http://localhost:8080/cat.jpg" (shows photo of 
			    a happy cat, and we like all happy animals!)</li><br>
			  <li>you should also see "GET /cat.jpg HTTP/1.1" in 
			    your terminal window, which is the "request line" 
			    that your browser sent to the server</li><br>
			  <li>Below that you should see all of the headers 
			    that your browser sent to server followed by
			    "HTTP/1.1 200 OK" which is the servers response 
			    to the browser</li><br>
			  <li>"http://localhost:8080/test/index.php" (should 
			    do a dir listing) NOTE: still getting this to work!</li><br>
			</ul>
		      </li><br>
		      <li><strong>Another way to test it:</strong>
			<ul>
			  <li>Open up Chromes developer tools, per the 
			    instructions at
			    "https://developer.chrome.com/devtools"</li><br>
			  <li>Then, once open, click the tools Network
			    folder, and then, while holding down Shift, reload 
			    the page.</li><br>
			  <li>Not only should you see Happy Cat again. You 
			    should also see the following in your terminal 
			    window.</li><br>
			  <li>"GET /cat.jpg HTTP/1.1"</li><br>
			  <li>"HTTP/1.1 200 OK"</li><br>
			  <li>You might also see the following.</li><br>
			  <li>"GET /favicon.ico HTTP/1.1"</li><br>
			  <li>"HTTP/1.1 200 OK"</li><br>
			  <li>Whats happening is, by convention, a lot of 
			    websites have in their root directory a
			    "favicon.ico" file, which is a tiny icon thats
			    meant to be displayed a browsers address bar or 
			    folder. If you do see those lines in your terminal 
			    window, that just means the browser (Chrome in
			    this example) is guessing that your server, too, 
			    might have "favicon.ico" file, which it
			    does!</li><br>
			</ul>
		      </li><br>
		      <li><strong>A Walkthrough Demo type test:</strong>
			<ul>
			  <li>"http://localhost:8080/cat.html" (shows photo of 
			    a happy cat, with a margin around him, unlike when 
			    it was just the jpg, due to Chromes default CSS 
			    properties)</li><br>
			  <li>If you look at the Chrome developer tools
			    Network folder (possibly after reloading, if they
			    werent still open), you should see that Chrome
			    first requested "cat.html" followed by "cat.jpg" , 
			    since the latter, recall, was specified as the
			    value of that img elements src attribute that we
			    saw earlier in "cat.html".</li><br>
			  <li>To confirm, take a look at the developer tools 
			    Elements folder, wherein you will see a pretty
			    printed version of the HTML in
			    "cat.html".  You can even change it but only
			    Chromes in memory copy thereof.</li><br>
			  <li>To tinker with the developer tools Styles
			    folder, even though this page doesnt have any CSS 
			    of its own, you can see and change (temporarily)
			    Chromes default CSS properties via that
			    folder.</li><br>
			  <li>If you look at the pages source code (as via
			    the developer tools Elements folder), you will see
			    your name embedded within the HTML! By contrast,
			    files like "cat.jpg" and "cat.html" (and even
			    "hello.html" ) are "static" content, since they are 
			    not dynamically generated.</li><br>
			  <li>To test code via a command line rather than with
			    a browser, this is one technique.</li><br>
			  <li>So lets show you one other technique.</li><br>
			  <li>Open up a second terminal window and position it
			    alongside your first.</li><br>
			  <li>In the first terminal window, execute:" ~/server public"
			    from within your own "~/workspace/webserver"
			    directory, if the server isnt already
			    running.</li><br>
			  <li>Then, in the second terminal window, execute the
			    below. (Note the "http://" this time instead of
			    "https://" .) "curl dash_i http://localhost:8080/".
			    If you havent used curl before, it is a command
			    line program with which you can send HTTP requests
			    (and more) to a server in order to see its
			    responses.  The "dash-i" flag tells curl to include
			    responses HTTP headers in the output. Odds are,
			    whilst debugging your server, you will find it more
			    convenient (and revealing!) to see all of that via
			    curl than by poking around Chromes developer
			    tools.  Incidentally, take care not to request
			    "cat.jpg" (or any binary file) via curl , else 
			    you will see quite a mess!</li><br>
			</ul>
		      </li><br>
		      <li><strong>"server.c" is a tour of what was
			    written by the online class people, and what I
			    wrote:</strong></li><br>
		      <li>In "server.c", only the lookup, parse, load, and
			indexes functions were written by me, as described
			in the previous section.</li><br>
		      <li>Next I describe what was done by the online course
			people in "server.c".</li><br>
		      <li>Atop the file are a bunch of "feature test macro
			requirements" that allow them to use certain functions
			that are declared (conditionally) in the header files 
			further below.</li><br>
		      <li>Defined next are a few constants that specify limits
			on HTTP requests sizes. They (arbitrarily) based their
			values on defaults used by Apache, a popular web
			server. See
			"http://httpd.apache.org/docs/2.2/mod/core.html".</li><br>
		      <li>Defined next is BYTES , a constant the specifies how
			many bytes we will eventually be reading into buffers at
			a time.</li><br>
		      <li>Next are a bunch of header files, followed by a
			definition of BYTE , which we have indeed defined as an
			8 bit char, followed by a bunch of
			prototypes.</li><br>
		      <li>Finally, just above main are a just a few global
		      variables.</li><br>
		      <li><strong>main: </strong>Atop main is an
			initialization of what appears to be a global variable
			called errno . In fact, errno is defined in "errno.h"
			and is used by quite a few functions to indicate (via
			an int ), in cases of error, precisely which error has
			occurred. See man errno for more details.</li><br>
		      <li>Shortly thereafter is a call to getopt , which is a 
			function declared in "unistd.h" that makes it easier
			to parse command line arguments. See man 3 getopt if
			curious.</li><br>
		      <li>Notice how we use getopt (and some Boolean
			expressions) to ensure that server is used
			properly.</li><br>
		      <li>Next notice the call to start (for which you may
			have noticed a prototype earlier). More on that
			later.</li><br>
		      <li>Below that is a declaration of a struct sigaction
			via which we will listen for SIGINT (i.e., "control c"), 
			calling handler (a function defined by us elsewhere in
			"server.c" ) if heard.</li><br>
		      <li>And then, after declaring some variables, main
			enters an infinite while loop.</li><br>
		      <li>Atop that loop, we first free any memory that might
			have been allocated by a previous iteration of the
			loop.</li><br>
		      <li>We then check whether we have been "signalled" via
			"control c" to stop the server.</li><br>
		      <li>Thereafter, within an if statment, is a call to
			"connected" , which returns true if a client (e.g., a 
			browser or even curl ) has connected to the
			server.</li><br>
		      <li>After that is a call to parse , which parses a
			browsers HTTP request, storing its "absolute path"
			and "query" inside of two arrays that are passed into
			it by reference.</li><br>
		      <li>Next is a bunch of code that decodes that path
			(decoding any URL encoded characters like "%20" ) and 
			"resolves" the path to a local path, figuring out
			exactly what file was requested on the server
			itself.</li><br>
		      <li>Below that, we ascertain whether that path leads to
			a directory or to a file and handle the request
			accordingly, ultimately calling list , interpret , or
			transfer .</li><br>
		      <li>For directories (that do not have an "index.php" or
			"index.html" file inside them), we call list in order
			to display the directorys contents.)</li><br>
		      <li>For files ending in ".php" (whose "MIME type" is
			"text/x_dash_php" ), we call interpret .</li><br>
		      <li>For other (supported) files, we call
		      transfer.</li><br>
		      <li>And that is it for main! Notice, though, that
			throughout main are a few uses of continue , the
			effect of which is to jump back to the start of that 
			infinite loop. Just before continue in some cases,
			too, is a call to error (another function they wrote)
			with an HTTP status code.  Together, those lines allow
			the server to handle and respond to errors just before 
			returning its attention to new requests.</li><br>
		      <li><strong>connected: </strong>connected is below main.
			"memset()" function fills the first sizeof(client
			socket address) bytes of the memory area pointed to by 
			(client socket address) with the constant byte
			zero.</li><br>
		      <li><strong>accept: </strong>extracts the first
			connection request on the queue of pending connections
			for the listening socket (server), sockfd, creates  a
			new connected socket, and returns a new file
			descriptor referring to that socket (for this client
			it just connected to).</li><br>
		      <li><strong>error: </strong>error calls "reason" to
			determine the reason for the failure of obtaining the 
			request for the client and places it in a phrase string.
			It forms a template string and then renders the template
			into a body string and its length.  It then adds the
			headers and responds with the error code, header,
			body, and length to the client. </li><br>
		      <li><strong>freedir: </strong>This function exists
			simply to facilitate freeing memory that is allocated
			by a function called scandir that we call in
			list.</li><br>
		      <li><strong>handler: </strong>This function (called
			whenever a user hits "control c") essentially tells
			main to call stop by setting signaled , a global
			variable, to true .</li><br>
		      <li><strong>htmlspecialchars :</strong>This function,
			named identically to that PHP function we saw earlier, 
			escapes characters "(e.g., < as < )" that might
			otherwise "break" an HTML page. We call it from list , 
			lest some file or directory we are listing have a
			"dangerous" character in its name.</li><br>
		      <li><strong>indexes: </strong>I wrote this function.
			It returns  a "path/to/a/directory" with either the html
			or php file extension on the end of it, if it actually 
			exists.  The function, given a "/path/to/a/directory", 
			returns "/path/to/a/directory/index.php" if
			"index.php" actually exists therein, or
			"/path/to/a/directory/index.html" if "index.html" 
			actually exists therein, or NULL . In the first of
			those cases, this function should dynamically allocate 
			memory on the heap for the returned string.</li><br>
		      <li><strong>interpret: </strong>This function enables
			the server to interpret PHP files. It is a bit cryptic
			at first glance, but in a nutshell, all we are doing,
			upon receiving a request for, say, "hello.php" , is
			executing a line like "QUERY_STRING='name=Alice'
			REDIRECT_STATUS=200 SCRIPT_FILENAME=/path/to/public"
			the effect of which is to pass the contents of
			"hello.php" to PHPs interpreter "(i.e., php_cgi )", 
			with any HTTP parameters supplied via an "environment
			variable" called QUERY_STRING. Via load (a function we
			wrote), we then read the interpreters output into
			memory (via load ). And then we respond to the browser 
			with (dynamically generated) output.
                      </li><br>
                      <li><strong>popen: </strong>That function opens a
			"pipe" to a process ( "php_cgi" in our case), which
			provides us with a FILE pointer via which we can read
			that processs standard output (as though it were an
			actual file).  You will notice how this function calls load , 
			though, in order to read the PHP interpreters output 
			into memory.</li><br>
		      <li><strong>list: </strong>A function that generates a
			directory listing. Notice how much code it takes to
			generate HTML using C, thanks to requisite memory
			management. (They pointed out here that with PHP this 
			part is easier).</li><br>
		      <li><strong>load: </strong>This is a function that I
			wrote to read all bytes from a web page. If it was
			html, it dynamically allocated memory on the heap, and
			saved a pointer to the web page content and length, or
			if a php web page request, invoke the php interpreter
			to run the requested php script, and return in content
			what the php script returned and it' length.
			<ul></ul><br>
			<p>1. reads all available bytes from file.</p>
			<p>2. stores those bytes contiguously in dynamically allocated memory on the heap.</p>
			<p>3. stores the address of the first of those bytes in "*content".</p>
			<p>4. stores the number of bytes in *length.</p>
			<p>Note that content is a "pointer to a pointer"
			  "(i.e., BYTE** )", which means that you can
			  effectively "return" a "BYTE*" to whichever function
			  calls load by dereferencing content and storing the
			  address of a BYTE at "*content" . Meanwhile, length is
			  a pointer "(i.e., size_t* )", which you can also
			  dereference in order to "return" a "size_t" to
			  whichever function calls load by dereferencing
			  length and storing a number at "*length".</p>
		      </li><br>
		      <li><strong>lookup:</strong> This is a function I wrote.
			It returns:
			<ul>
			  <li>"text/css" for any file whose path ends in
			".css" (or any capitalization thereof)</li><br>
			  <li>"text/html" for any file whose path ends in ".html"
			(or any capitalization thereof)</li><br>
			  <li>"image/gif" for any file whose path ends in
			    ".gif" (or any capitalization thereof)</li><br>
			  <li>"image/x_dash_icon" for any file whose path ends in
			    ".ico" (or any capitalization thereof) </li><br>
			  <li>"image/jpeg" (not image/jpg ) for any file whose
			    path ends in ".jpg" (or any capitalization
			    thereof),</li><br>
			  <li>"text/javascript" for any file whose path ends
			    in ".js" (or any capitalization thereof)</li><br>
			  <li>"text/x_dash_php" for any file whose path ends in
			    ".php" (or any capitalization thereof)</li><br>
			  <li>"image/png" for any file whose path ends in
			    ".png" (or any capitalization thereof)</li><br>
			  <li>or NULL otherwise.</li><br>
			</ul>
		      </li><br>
		      <li><strong>parse: </strong>This is a function that I
			wrote to extract the absolute path and query from the
			client web browsers web page request line, and return
			standard web error messages if the request had an error.
			The function parses (i.e., iterates over) the "line"
			argument it is given, extracting its absolute path and
			query and storing them at "abs_path" and "query", 
			respectively.
			<ul></ul><br>
			<p><strong>abs_path:</strong>("Per 3.1.1 of
			  http://tools.ietf.org/html/rfc7230
			  (http://tools.ietf.org/html/rfc7230)"), is a request
			  line is defined as method SP request target SP HTTP
			  version CRLF wherein SP represents a single space "(
			  )" and CRLF represents "\r\n" . None of method ,
			  request target , and HTTP version meanwhile, may
			  contain SP. (Per 5.3 of the same RFC),
			  request target, meanwhile, can take several forms,
			  the only one of which your server needs to support
			  is "absolute path [ '?' query ]" whereby
			  "absolute path" (which will not contain '?' ) must
			  start with '/' and might optionally be followed by a
			  '?' followed by a query ,which may not contain
			  double quotes.  We had to ensure that request line
			  (which is passed into parse as line) is consistent
			  with these rules. If it is not, we responded to the 
			  browser with "400 Bad Request" and returned false.
			  Even if request line is consistent with these rules, 
			  if method is not GET, we responded to the browser
			  with "405 Method Not Allowed" and return false.
			  If request target does not begin with '/' , we
			  responded to the browser with "501 Not Implemented" 
			  and return false. If request target contains a
			  double quote , we responded to the browser with 
			  "400 Bad Request" and returned false.  If HTTP
			  version is not "HTTP/1.1" , we responded to the
			  browser with "505 HTTP Version Not Supported" and 
			  returned false.  If all is well, we stored
			  "absolute path" at the address in "abs_path" 
			  (which was also passed into parse as an
			  argument). We could assume that the memory to which
			  "abs_path" points was at least of length
			  "LimitRequestLine + 1".</p>
			<p><strong>query: </strong>We stored at the address in
			  query the query substring from request target. If
			  that substring was absent (even if a '?' is
			  present), then query should be 2 double quotes ,
			  thereby consuming one byte, whereby query[0] is
			  "\0". We could  assume that the memory to which
			  query points was at least of length "LimitRequestLine + 1".
			  For instance, if request target is "/hello.php" or
			  "/hello.php?", then query should have a value of
			  double quotes . And if request target was
			  "/hello.php?q=Alice", then query had value of
			  "q=Alice".</p>
		      </li><br>
		      <li><strong>reason: </strong>This function simply
			mapped HTTP "status codes" (e.g., 200 ) to "reason
			phrases" (e.g., OK ).</li><br>
		      <li><strong>redirect: </strong>This function redirects
			a client to another location (i.e., URL) by sending a
			status code of 301 plus a Location header.</li><br>
		      <li><strong>request: </strong>When the server receives
			a request from a client, the server does not know in
			advance how many characters the request will
			comprise. So this function iteratively reads bytes
			from the client, one buffers worth at a time, calling 
			realloc as needed to store the entire message (i.e.,
			request).  Notice this functions use of pointers,
			dynamic memory allocation, pointer arithmetic, and
			more.  Ultimately, it keeps reading bytes from the
			client until it encounters "\r\n\r\n" (aka CRLF CRLF), 
			which, according to HTTPs spec, marks the end of a 
			requests headers.  Note that read() is quite like
			fread except that it reads from a "file descriptor" 
			(i.e., an int ) instead of from a FILE pointer "(i.e.,
			FILE* )".</li><br>
		      <li><strong>respond: </strong>It is this function that
			actually sends a client an HTTP response, given a
			status code, head, body, and that bodys length. 
                        </li><br>
                       <li>Know that dprintf is quite like printf (or, really,
			 fprintf ) except that the former, like read , writes
			 to a "file descriptor" instead of to a FILE*
			 .</li><br>
		       <li><strong>start: </strong>Start is the function that
			 configures the server to listen for connections on a 
			 particular TCP port!</li><br>
		       <li><strong>stop: </strong>Stop does the opposite,
			 freeing all memory and ultimately compelling the
			 server to exit, without even returning control to
			 main.</li><br>
		       <li><strong>transfer()</strong> This functions purpose
			 in life is to transfer a file from the server to a
			 client. Whereas interpret handles dynamic content
			 (generated by PHP scripts), transfer handles static
			 content (e.g., JPEGs). Notice how this function calls
			 load in order to read some file from disk.</li><br>
		       <li><strong>urldecode()</strong> This function, also
			 named after a PHP function, URL decodes a string,
			 converting special characters like "%20" back to
			 their original values.</li><br>
		       <li><strong>Current Status of Web Server in C:</strong>
			 Works for HTML static page requests, but not for a
			 PHP request to return a directory, and the simple
			 Perl script mentioned below has not yet been
			 tried.</li><br>
		       <li><strong>Possible plans for expanding the web server
		       implemented in C described above (there are 2 parts to
		       it):</strong>
			 <ul></ul><br>
			 <p>This part is similar to what I did in the online
			   class assignment: write a C/C++ program that implements a web
			   server. This web server will conform to "HTTP/1.x" 
			   for the purposes of client requests, and it will
			   need to process client HTTP GET requests for web
			   pages hosted on the server machine.  It will need
			   to use sockets to implement the communication
			   between a client on one machine and the server on
			   either the same or a remote machine.</p><br>
		       <li><strong>Add Interaction of physical computing with the web
			 server:</strong> The new part, described in more
			 detail below, will be adding functionality to the
			 web server to support
			 interaction with a physical device, a case where
			 computers interact with the physical world through a
			 collection of sensors and actuators. This forms a
			 physical computing environment.</li><br>
		       <li><strong>Web server Description:</strong>
			 <ul></ul><br>
			 <P><strong>The Basic HTTP Protocol:</strong> The basic structure of
			   interaction between a web client and web server is
			   as follows:</p>
			 <ul>
			   <li><strong>Client</strong> sends request (from a suitable
			   browser)</li><br>
			   <li>GET filename HTTP/version</li><br>
			   <li>optional arguments</li><br>
			   <li>a blank line</li><br>
			   <li>Server sends reply</li><br>
			   <li>"HTTP/version" status code status
			   message</li><br>
			   <li>additional information</li><br>
			   <li>a blank line</li><br>
			   <li>content</li><br>
			   <li>It will need to ensure the information sent
			     back from the server is formatted as described
			     above.</li><br>
			   <li>The additional information sent back in a
			     server reply is of the form:
			     <p>"Content-type:text/plain"</p>
			     <p>"text/html"</p>
			     <p>"image/gif"</p>
			     <p>"image/jpeg"</p>
			     <p>"xxx/yyy"</p>
			   </li><br>
			   <li><strong>The Server</strong>
			     <ul>
			       <li>Assume the server forks a child
			       process for each incoming request.</li><br>
			       <li>Additionally, assume each request involves
				 establishing a new connection with the
				 server, rather than maintaining any notion of
				 a session for multiple requests.</li><br>
			       <li>The  web server is in a file called
				 "webserv.c".</li><br>
			       <li>For execution, bind the server to a
			       specific port.</li><br>
			       <li><strong>To run the web server,
			       type:</strong>
				 <ul></ul><br>
				 <p>"$./webserv port-number"</p>
				 <p>where "port-number" should be a value in
				   the range 5000-65536 such as 8080.</p>
			       </li><br>
			       <li>The server will handle a
				   series of requests, such as listing the
				   contents of a directory on the server
				   machine, retrieving a file for viewing on
				   the client, and running cgi scripts.</li><br>
			       <li>In particular, the server will handle
				   static and dynamic content requests. In the
				   former case, the content is simply
				   retrieved from a preexisting file on the
				   server. For dynamic content, you will be
				   expected to run a program on the server, to
				   process data and generate an HTML compliant
				   file for sending back to the client.</li><br>
			       <li>The web server will handle HTML status
				   codes 200 (successful request), 404 (Not
				   Found), and 501(Not Implemented). For
				   status code 501, the server does not
				   recognize the request method. Further
				   information about status codes can be
				   found.</li><br>
			     </ul>
			   </li><br>
			   <li><strong>The Client</strong>
			     <ul></ul><br>
			     <p>The client is any web browser of your
			       choice.</p> 
			     <p>Requests from the client should be in the
			     form:</p>
			     <ul>
			       <li>"http://ip.address.of.server:port-number/request"
				 <ul></ul><br>
				 <p>"ip.address.of.server" the IP address of
				 the server machine</p>
				 <p>"port-number" numeric port on which the
				   server listens.</p>
				 <p>Together with the IP address, this
				   identifies an end point of communication
				   (or socket) to which the client
				   connects.</p>
				 <p><strong>request </strong>either a
				   subdirectory on the server that you wish to
				   list, the name of a html file, or a cgi
				   file.  In the latter case, a reference to a
				   script on the server ia executed to perform
				   some command. The content of a cgi script,
				   such as "test.cgi", must be set executable
				   on the server and must refer to a shell or 
				   Perl script such as the following:</p>
				 <p>"test.cgi" (set executable using chmod 755 "test.cgi"):</p>
				 <p>"#!/bin/sh"</p>
				 <p>"# test.cgi" a simple test</p>
				 <p>printf "Content-type: text/plain\n\nThis is a test!\n"</p>
				 <p>To execute a Perl script, you can issue a request such as:</p>
				 <p>"http://ip.address.of.server:port-number/request.cgi"</p>
				 <p>where "request.cgi" is an executable Perl
				   script on the server having contents such
				   as:</p>
				 <p>"#!/usr/bin/perl"</p>
				 <p>"# perl-test.cgi -- a simple Perl script
				 test"</p>
				 <p>print "Content-type: text/plain\n\nThis is a Perl test!\n;"</p>
			       </li><br>
			     </ul>
			   <li><strong>Basic Test Cases:</strong>All of
			       the followiing test cases will be supported:
			     <ul>
			       <li>A request for a directory
				   listing</li><br>
			       <li>A request for a valid (and non
				     existing) html file. NOTE: A nonexistent
				     request corresponds to an HTTP error
				     status code of 404.</li><br>
			       <li>A request for a static image (in either
				     gif or jpeg format, having a file ending
				     of .gif, .jpg or .jpeg)</li><br>
			       <li>A request for a cgi script that
				   requires execution of a basic shell
				   command, executed using sh</li><br>
			       <li>A request for a perl script in a cgi
				   file to process raw data and format it into
				   an html file.</li><br>
			       <li>A request for a dynamically-created
				   image using gnuplot on the
				   server. Information about gnuplot can be
				   found at:
				   "http://www.gnuplot.info/"</li><br>
			       <li>For the latter case, above, it is assumed
				   that the request specifies a cgi file
				   describing a perl script. The perl script
				   will process data as described in the next
				   subsection.</li><br>
			       <li>Dynamic Content using Gnuplot: In this
				     case, a program will be executed
				     on the server called
				     "my histogram", as follows: "$my-histogram file pattern1 pattern2 ... patternN"
				     file specifies the name of a file you
				     wish to search for all occurrences of a
				     given regular expression pattern or
				     string sequence. For example:
				     "$my-histogram file 'and' 'but' 'so' 'he.*lo'"
				     will tally all occurrences of the words
				     "and", "but" and "so" in file, 
				     along with all strings that match the
				     pattern "he.*lo" such as "hello" etc. 
				     You can assume all regular expression
				     patterns that are acceptable 
				     to grep "-e" are valid. You can assume
				     the number of pattern 
				     arguments is limited to 5.</li><br>
			       <li>Once "my histogram" has tallied all
				     occurrences of the matching strings for
				     each pattern, the results will be plotted
				     as a histogram using gnuplot. The output
				     of "my histogram" will be piped to
				     gnuplot using a Perl command as follows:
				     "open (GNUPLOT, '|gnuplot'); # Notice the vertical bar for a pipe"
				     After which piping commands to gnuplot is analogous to writing to a file.
				     "my histogram" will be written in C, but any
				     language can be used, Python,
				     Perl, etc. You are also free to use 
				     shell commands such as "grep -e" if you
				     wish, or the built in Perl regular
				     expression features. 
				     The output of gnuplot histogram will be formatted
				     to show "frequency" up 
				     the y axis and the labelled patterns on
				     the x axis, so there is one frequency bar
				     per pattern.</li><br>
			       <li>Next, gnuplot will be commanded to
				     output the histogram to a file that
				     records the information in gif or jpeg
				     format.</li><br>
			       <li>After this, the cgi script will send
				     your gnuplot gif or jpeg image back to
				     the client for viewing.</li><br>
			       <li><strong>Pretty Printed Output</strong>
				     Just as this webpage has been formatted
				     using html, an executable on the server
				     will be invoked as part of your CGI
				     script to pretty print your
				     histogram.</li><br>
			       <li>Specifically, the histogram image file
				     will be embedded in an HTML page that has
				     a 16pt RED font title and white
				     background. 
				     The title should read: "My Webserver". 
				     (I may experiment with the generated HTML
				     content, producing image backgrounds and 
				     additional details. The base case will be 
				     formatted as described,
				     however.)</li><br>
			       <li>The title will be centered on the
				   page. Below it, will be a blank line
				   (spacing of which is your choosing)
				   followed by the histogram, which is also
				   centered.</li><br>
			       <li><strong>Advanced Features:</strong> 
				     <strong>A multi threaded web
				       server:</strong> Instead of using 
				     "fork()" calls for each client request,
				       instead spawn a thread using
				       my own thread creation routines,
				       based on the signaltstack() method. 
				     Specifically,
				       "make/get/set/swapcontext()" functions
				       or any pre-existing thread packages
				       (e.g., pthreads) will NOT be
				       used. Instead, my own thread management
				       code.</li><br>
			       <li><strong>A web cache:</strong> I will
				     develop a method to cache files in RAM
				     for subsequent requests. The RAM cache
				     should be a pool of memory of some
				     defined size. This will to be a tunable
				     parameter from 4KB to 2MB.</li><br>
			       <li>Upon initialization, the cache is
				     empty, but gets filled for each file
				     request until it is full. At that point
				     I will adopt a simple replacement
				     strategy my choice (e.g., first in
				     first out, random, or least recently
				     used).</li><br>
			       <li>I will specify my replacement method in
				     a README file. To make the cache
				     beneficial, you should support requests
				     that are both in the server's filesystem
				     and also on a remote host.</li><br>
			       <li>Client requests should provide an
				     optional argument to indicate the remote
				     host location for files that are not
				     stored in the server's local
				     filesystem.</li><br>
			       <li>To test this feature, the server act
				     like a client for a remote host machine,
				     thereby retrieving the necessary file(s)
				     for placement in the web cache. In turn,
				     these files will be relayed back to the
				     original client.</li><br>
			       <li><strong>Server configuration.</strong>
				     For testing purposes, a way will be
				     provided to disable the above advanced
				     features, so that the web server falls
				     back to operating in normal mode (without 
				     web caching and threads). This means I
				     will produce only one version of my
				     code. To enable or disable features of my
				     server, I will either use a configuration
				     script, pass in command line arguments,
				     or (worst case) use defined constants
				     within your code.</li><br>
			       <li><strong>Physical Computing</strong>
				     (NOTE: I may use what I learned in my
				     embedded systems online class projects
				     for this section, not sure yet, and that 
				     is described separately).</li><br>
			       <li>To tackle this part of the assignment
				     requires me to have access to an Arduino
				     Uno or similar Arduino compatible device.
				     (In my embedded systems class, we used a
				     TI Cortex M Arm based microcontroller
				     Launch board, but I may instead use an
				     Arduino).  These can be purchased for
				     about "$5.99" (roughly the price of two
				     coffees) from places such as Microcenter.
				     You can also buy a good quality starter
				     kit from Amazon, which is a little more
				     expensive but includes everything to get 
				     going with some basic building projects. 
				     If I have access to a Raspberry Pi or
				     other similar single board computer, I
				     can use that too.</li><br>
			       <li><strong>The idea: as a way to do
				       physical computing, I will be creative
				       for this physical computing
				       section. One idea would be to have an
				       Arduino board connected via a serial
				       interface to a server PC running the
				       web server I have created.</li><br>
			       <li>A client would initiate requests to my
				     web server, which would then issued
				     serial commands to my Arduino board. 
				     My Arduino board would run some code (of
				     my choosing) to perform a control
				     operation.</li><br>
			       <li>For example, a simple control operation
				     would be to turn on and off some LEDs, or
				     to control the speed and angle of a
				     stepper or servo motor.  There are
				     numerous examples of doing this in my
				     embedded systems class labs, but I may do
				     something different here.</li><br>
			       <li>All these operations would be triggered
				     by client requests via a web browser,
				     through which commands are sent via my
				     web server.</li><br>
			       <li>Another option would be to simply use a
				     web interface to submit requests to
				     upload Arduino "sketches" to my target
				     device.</li><br>
			       <li>Here, a sketch is a simple program that
				     runs out of the ROM space on the Arduino
				     itself.</li><br>
			       <li>The Arduino IDE is open source and can
				     be downloaded for most OSes, and there is
				     a reference guide to explain the simple
				     programming language available
				     online.</li><br>
			       <li><strong>Why tackle the physical computing section?</strong>
				     You also get to work with physical
				     devices which is a lot of fun. 
				     It makes computing feel "real" rather
				     than abstract. Writing programs 
				     that make computers work is one thing,
				     but having those computers 
				     control devices is the basis for how
				     robots, 3D printers, UAVs and all 
				     sorts of physical devices
				     operate.  This physical computing section
				     also allows me to be creative. I come up
				     with any physical computing problem of my
				     choosing, as long as the control is
				     initiated through the web
				     server.</li><br>
			       <li><strong>DEMO (if I ever finish, will post a video):</strong>
				 <ul>
				   <li><strong>Basic test cases for static content</strong>
					 (including directory listings,
					 correct error reporting, static 
					 images and cgi scripts). This should
					 include correct usage of sockets 
					 to enable client requests and correct
					 handling of HTML client request
					 formats</li><br>
				   <li><strong>Dynamic content</strong> including regular
					 expression handling and histogram and
					 gnuplot generation</li><br>
				   <li><strong>Pretty printed output</strong>, including
					 correct embedding of images in
					 HTML-formatted files</li><br>
				   <li><strong>Advanced features</strong>thread management
					   and the web cache (including proxy
					   support for remote 
					 requests and cache
					   replacement)</li><br>
				   <li><strong>Server configuration
					   Program style and 
					   documentation</strong> (in a README file)</li><br>
				 </ul>
			       </li><br>
			     </ul>
			 </ul>
           </div>
	</body>
</html>
